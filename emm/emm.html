<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Toward an exploratory medium for mathematics</title>
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="stylesheet" type="text/css" href="prototype.css">

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$']]},
      "HTML-CSS": 
      {scale: 92},
      TeX: { equationNumbers: { autoNumber: "AMS" }}});
    </script>
    <script type="text/javascript" src="mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="jquery/jquery-2.1.4.min.js"></script>
    <!-- My libraries -->
    <script type="text/javascript" src="emm.js"></script>
    <script type="text/javascript" src="prototype.js"></script>
    <script type="text/javascript" src="canvas.js"></script>
  </head>

  <body>
    <div id="header">
      <h1>Toward an exploratory medium for mathematics</h1>
      <p>
	<a href="http://michaelnielsen.org">Michael Nielsen</a> &nbsp; / &nbsp;
	<a href="http://www.recurse.com">Recurse Center</a> &nbsp; / &nbsp; February 2016
      </p>
    </div>

    <div id="container">

      <p>
	<em>XXX: Note that when I write XXX it means something that
	  needs fixing, i.e., it's not part of the main document.</em>
      </p>
	
      <p>
	The world's oldest complete piece of surviving music is the
	3,400 year
	old <a href="https://en.wikipedia.org/wiki/Hurrian_songs">Hurrian
	cult hymn</a>.  A transcription of the hymn was found
	inscribed on clay tablets excavated from the ancient city of
	Ugarit, located in modern-day Syria.  Sometime after the hymn
	was composed, the idea of using notation to record music was
	lost.  Writing two millenia later, in the seventh century CE,
	the polymath Isidore of Seville stated that &ldquo;unless
	[musical] sounds are held by the memory of man, they perish,
	because they cannot be written down.&rdquo;
      </p>

      <p>
	In the ninth century, European musicians began experimenting
	with notations to record plainchant.  The initial notations
	were rough.  They didn't precisely denote either pitch or
	rhythm, and were probably intended more as an aid to memory
	than as a recording medium.  But they gradually improved.  In
	the 11th century, Guido of Arezzo introduced the musical
	staff, making it easy to record pitch.  And in the 13th
	century, Franco of Cologne suggested using a written note's
	appearance to signify duration.  These and many other ideas
	led to modern musical notation.
      </p>

      <p>
	Modern written music may have originated as a recording
	medium, but it gradually became a creative medium in its own
	right.  It made it much easier to compose complex, intricate
	music for many instruments and many voices.  This paved the
	way for Bach's fugues, Beethoven's symphonies, and so much
	else.  Written music became a medium for thought, a medium
	which helped expand the range of musical ideas a composer
	could have, and thus changed music itself.  It's an example of
	what I shall call a <em>cognitive medium</em> &ndash; an
	environment to support and enable thought.
      </p>

      <p>
	In the modern day, digital computers have spurred the
	invention of many new cognitive media.  Consider a program
	such as Photoshop.  Adept users of Photoshop internalize tools
	such as the lassoo, the eyedropper, the clone stamp, and so
	on.  The tools become part of the way they think about image
	manipulation, and gradually expand the range of graphical
	ideas they can have.
      </p>

      <p>
	Photoshop is just one of the many cognitive media invented for
	digital computers.  Other examples include musical
	scorewriting programs such as Finale and Sibelius, 3d
	modelling programs such as Blender and 3ds Max, and video game
	engines such as Unity and Unreal.  Such media enable users to
	think and create in ways that would otherwise be difficult or
	impossible.  They are a way of augmenting human
	intellect*<span class="marginnote">* This notion has been
	extensively developed by many researchers.  See, for example,
	Douglas
	Engelbart's <a href="refs/Engelbart1962.pdf">Augmenting Human
	Intellect: A Conceptual Framework</a>, and Alan Kay and Adele
	Goldberg's <a href="refs/Kay1977.pdf">Personal Dynamic
	Media</a>.</span>.
      </p>

      <p>
	This essay is about the design of cognitive media for
	mathematics.  Well-known cognitive media for mathematics
	include programs such as Mathematica, Matlab, Sage, and Coq.
	These programs are useful, but conservative, in that the
	programs mostly aim to automate the solution of problems that
	would have been familiar to mathematicians of the 1950s.  By
	contrast, in recent years many
	people*<span class="marginnote">* A partial list
	includes <a href="http://worrydream.com/">Bret
	Victor</a>, <a href="http://marctenbosch.com/vi ">Marc ten
	Bosch</a>, and <a href="https://acko.net/about/">Steven
	Wittens</a>.</span>  have experimented with media which don't
	just accept the basic language of mathematics as given, but
	rather attempt to change the fundamental representations and
	operations used in mathematical work.  Over the long run, I
	believe this kind of experimentation will radically change how
	we think about mathematics.
      </p>

      <p>
	As a step in this direction, in this essay I'll show a simple
	prototype medium which lets the user explore in a particular
	part of mathematics, namely, linear algebra.  The prototype is
	based on three main ideas:
      </p>

      <p>
	<strong>1. A concrete, graphical medium based on direct
	manipulation:</strong> When using paper-and-pencil (or its
	close cousin, blackboard-and-chalk), mathematicians often
	explore using informal, concrete, graphical representations,
	like those shown in the image to the
	right.<span class="marginnote">* <a href="https://commons.wikimedia.org/wiki/File:HD.3A.053_(10481714045).jpg">Photo
	credit:</a> United States Department of Energy.</span>
	<img src="images/blackboard.jpg" width="350px" style="float:
	right; margin: 5px 0px 5px 10px;"/> Such exploration is often
	difficult in existing computer-based cognitive media.  While
	systems such as Mathematica are good at producing graphical
	output, they're not aimed at direct manipulation of those
	graphical representations.  This make it difficult to reason
	in the concrete, graphical way common with paper-and-pencil.
	In this sense, paper-and-pencil is a medium which has never
	been entirely surpassed for mathematical work.  Is it possible
	to strictly improve on paper-and-pencil as a medium for doing
	mathematics?  Our prototype medium will aim to make direct
	manipulation easy.  The intent is to combine the flexibility
	and concreteness of paper-and-pencil with the automated
	inference that is the raison d'Ãªtre of traditional systems for
	doing mathematics by computer. Think something like
	&ldquo;Photoshop for linear algebra&rdquo;.  That grossly
	overstates what we'll do, but has the benefit of conveying the
	right gist.
      </p>


      <p>
	<strong>2. Work on a genuine mathematical problem, not a toy
	or &ldquo;educational&rdquo; problem:</strong> We'll develop
	our prototype as we work through a piece of genuine
	mathematics. It's a beautiful result in linear algebra called
	the <em>singular value decomposition</em>, or <em>SVD</em> for
	short. Aiming at the SVD makes the essay less accessible than
	working with a toy problem, but has the benefit that it forces
	us to confront and overcome the sort of problems which arise
	in real mathematical work.  Of course, ideally we'd go even
	further than re-discovering existing mathematics, and use the
	medium to discover new mathematics.  We won't achieve that
	here, but over the long run, this is the most stringent (and
	best) test of the utility of an exploratory cognitive medium:
	does it enable the development of important new mathematical
	ideas?
      </p>

      <p>
	<strong>3. A medium for exploration and discovery, not
	  explanation:</strong> Earlier, I mentioned the experimental
	  cognitive media developed over the past few years.  Many of
	  these media are intended primarily as <em>explanations</em>
	  &ndash; see, for a beautiful example, Vi Hart and Nicky
	  Case's <a href="http://ncase.me/polygons/">explanation</a>
	  of one of the economist Thomas
	  Schelling's <a href="refs/Schelling1971a.pdf">models of
	  social behavior</a>.  By contrast, the prototype medium
	  we'll develop is intended as an open-ended environment for
	  exploration and discovery.  In essence, we'll be working
	  through a <em>re-discovery</em> of the SVD.  I mention this
	  because exploration and discovery is inherently a messier
	  and more <em>ad hoc</em> process than explanation, and so
	  you should expect this to be somewhat less legible than a
	  straight-up explanation of the SVD.
      </p>

      <p>
	<strong>What do we learn about cognitive media?</strong>  The
	prototype itself is not the main point of the essay.  Rather,
	we shall learn something striking and important from the
	prototype medium.  In particular, we'll identify a fundamental
	problem in the design of exploratory cognitive media.  The
	problem arises from desiring a medium that simultaneously: (1)
	automates computation and inference, as we expect a
	computer-based medium to do; and (2) allows the user to
	flexibly change assumptions on the fly, in a manner similar to
	that allowed by paper-and-pencil.
      </p>

      <p>
	We'll show that the ability to flexibly edit assumptions
	sometimes makes it impossible to automate inference in other
	parts of the system.  Mathematical inconsistencies arise:
	there is no single ground truth in the system, but rather
	multiple ground truths.  These inconsistencies are not an
	accident or specific to our particular medium.  Rather, they
	are inevitable in any cognitive medium that tries to
	simultaneously get the benefits of paper-and-pencil and the
	ability to automatically do computations and inference.  To
	resolve this problem, we must develop both an internal data
	model for the medium and a user interface that lets us reason
	about these multiple ground truths.  We'll identify a set of
	principles that enable us to do this.  These principles and
	the problem they solve will be important in any exploratoy
	medium for mathematics.
      </p>


      <p>
	<h2>Introducing the singular value decomposition</h2>
      </p>

      <p>
	If you're not familiar with the SVD, it's a way of breaking a
	matrix up into three simple components.  It's most easily
	understood for a real $2 \times 2$ matrix $M$, where the SVD
	guarantees that it's always possible to break $M$ up into a
	rotation about the origin, followed by a rescaling of the
	co-ordinate axes, followed by a second rotation about the
	origin.  Each of these three components is easy to reason
	about individually, and that can often make it easy to reason
	about the matrix as a whole.  The great thing about the SVD is
	that it guarantees that <em>every</em> $2 \times 2$ matrix can
	be broken up in this way, for suitable choices of rotations
	and rescaling*<span class="marginnote">* Actually, the full
	statement of the SVD is slightly more complex.  I'll explain
	it in a moment.</span>.  It's similar to the way knowing the
	prime factorization of a number can make it easier to reason
	about that number.
      </p>

      
      <p>
        The SVD doesn't just apply to $2 \times 2$ matrices.  For a
        real $n \times n$ matrix $M$, the SVD says such a matrix can
        always be decomposed as*<span class="marginnote">* There are
        versions of the SVD which apply to non-square matrices, to
        infinite matrices and linear operators, and to matrices over
        fields other than the real numbers.  For our purpose, the $n
        \times n$ real case is a good level of generality.  Many of
        the ideas can, in any case, be reused in more general
        contexts. </span>
      </p>

      <p>
	\begin{eqnarray}
	M = U \, {\rm diag}(s_1, s_2, \ldots, s_n) \, V.
	\end{eqnarray}
      </p>

      <p>
	Here, the matrices $U$ and $V$ are real $n \times
	n$ <em>orthogonal</em> matrices.  As you may guess from the
	earlier discussion, orthogonal matrices are generalizations of
	the 2-dimensional rotations.  In particular, they're simply
	matrices which <em>preserve length</em> in $n$ dimensions,
	just as rotations preserve length in 2 dimensions.  That is,
	if $U$ is an orthogonal matrix and $v$ is any vector, then the
	length $\|U v\|$ is always the same as the length $\|v\|$.
	Formally, a square matrix $U$ is defined to be orthogonal if
	$U^T U = I$, where $T$ is the transpose operation, and $I$ is
	the identity matrix*<span class="marginnote">* To see how this
	relates to length preservation, observe that $\|v\|^2 = v^T
	v$, i.e., the sum of the squares of the components of $v$.
	Using this observation we have $\|Uv \|^2 = v^T U^T U v = v^T
	v = \|v\|^2$, where we substituted $U^T U = I$ to obtain the
	second equality.</span>.  And so in the case of the SVD we
	have $U^TU = I$ and $V^T V = I$.
      </p>

      <p>
	The other part of the singular value decomposition $(1)$ was
	the diagonal matrix ${\rm diag}(s_1, s_2, \ldots, s_n)$.  The
	diagonal entries $s_1 \geq s_2 \geq \ldots \geq s_n \geq 0$
	are known as the <em>singular values</em> of the matrix $M$.
	These singular values simply rescale the corresponding
	directions in $n$-dimensional vector space. Putting it all
	together, the SVD tells us that any matrix can be broken up
	into an orthogonal &ldquo;rotation&rdquo;, followed by a
	rescaling, followed by another orthogonal
	&ldquo;rotation&rdquo;*<span class="marginnote">* I told a
	small lie in my explanation of the $2 \times 2$ case.  The $2
	\times 2$ orthogonal matrices include not just rotations, but
	also reflections.  As an example, consider the matrix
	$\begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix}$, which
	reflects about the $x$ axis.  It's easily verified that this
	is an orthogonal matrix, but it's most certainly not a
	rotation.  In fact, you can show that an arbitrary $2 \times
	2$ orthogonal matrix is either a rotation, or can be written
	as a product of $\begin{bmatrix} 1 & 0 \\ 0 & -1
	\end{bmatrix}$ with a rotation.  An analogous statement is
	true in $n$ dimensions.  In practice, you mostly won't be led
	astray if you ignore the reflections, and think of orthogonal
	matrices as rotations in $n$ dimensions.</span>.
      </p>

      <p>
	While we're going to prove the SVD, the proof is not the main
	point of the essay. As such, I will take it for granted that
	you're willing to believe the SVD is interesting.  This means
	we won't get deeply into the applications or meaning of the
	SVD.  But with that said, it's worth knowing that the SVD is a
	very widely-used tool, for applications ranging
	from <a href="https://en.wikipedia.org/wiki/Latent_semantic_analysis">natural
	language processing</a>
	to <a href="https://en.wikipedia.org/wiki/Schmidt_decomposition">quantum
	computing</a> to
	the <a href="https://en.wikipedia.org/wiki/Kabsch_algorithm">comparison
	of protein structures</a>.  Indeed, it's one of the most
	useful tools in linear algebra, and arguably in all of
	mathematics.
      </p>

      <!-- Pretty redundant.  Most readers will figure this out from
      the few paragraphs above.
	   
      <p>
	To read the remainder of the essay, you will need to be
	comfortable with basic linear algebra, at about the level
	already required in this section.  In particular, you should
	be comfortable with notions such as the transpose, matrix
	multiplication, orthonormality, and so on.
      </p>
      -->

      <p>
	<h2>A proof of the SVD for $2 \times 2$ matrices</h2>
      </p>

      <p>
	In this section I explain the proof of the SVD in the case
	when $M$ is a $2 \times 2$ matrix.  This proof contains all
	the essential ideas needed for the general proof, which we'll
	discuss later.
      </p>

      <p>
	Rather than attack the problem head-on, let's start with a
	simpler and more natural problem.  This problem will appear
	unrelated, but as we attempt to solve this problem our
	explorations will lead us to the SVD.
      </p>

      <p>
	The simpler problem is the question of how much a $2 \times 2$
	matrix $M$ <em>stretches</em> space?  To understand what I
	mean by stretching space, consider the matrix
      </p>

      $$M = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}.$$

      <p>
	If we let this matrix act on the vector $(1, 0) \equiv
	\begin{bmatrix} 1 \\ 0 \end{bmatrix}$ the vector becomes
      </p>

      $$M \begin{bmatrix} 1 \\ 0 \end{bmatrix} = \begin{bmatrix} 1 \\
      1 \end{bmatrix} $$

      <p>
	The input vector $(1, 0)$ has length $1$, while the output
	vector $(1, 1)$ has length $\sqrt 2$.  So the matrix stretches
	this particular input vector to become a factor $\sqrt{2}$
	longer.
      </p>

      <p>
	Of course, $(1, 0)$ isn't the only possible input vector.  If
	the input were, say, $(0, 1)$ the output would be $M(0, 1) =
	(1, 0)$, which is the same length as the input.  In that
	direction, $M$ doesn't stretch space at all.
      </p>

      <p>
	The question we'll investigate is this: what is
	the <em>maximal</em> degree of stretching associated to some
	given matrix, $M$?  In other words, if we consider all unit
	vectors $v$, what is the maximal value for the length $\| M
	v\|$?
      </p>

      <p>
	I'm abusing terminology a little here &ndash; $M$ might
	actually shrink unit vectors in some directions, or even in
	every direction.  But the term &ldquo;stretch&rdquo; is
	evocative, so we'll continue using
	it*<span class="marginnote">* Stretching is not a standard
	mathematical term.  Mathematicians often refer to this maximal
	stretching as the matrix norm, or, a little more formally, as
	the matrix norm induced by the Euclidean distance.</span>.
      </p>

      <p>
	We won't solve this problem immediately, but will instead do
	some exploration that helps us understand the problem.  The
	exploration will be illustrated using a rough prototype of a
	cognitive medium for doing linear algebra.  Think of what
	follows as someone doing real, live mathematical work, trying
	to better understand the maximal degree of stretching
	associated to a $2 \times 2$ matrix.  This is a record of
	their explorations. To start the demo, please click
	&ldquo;Play&rdquo; below.  Of course, in a real medium, you'd
	be able to interrupt, do your own exploration, and so on.  But
	this is just a prototype, to explore ideas, and so I haven't
	built the medium out to do that.  Here it
	is*<span class="marginnote">* <em>XXX: When the essay ships, I
	will replace this with a video with audio voiceover rather
	than ticker-tape, making it easy to move backward and forward
	through the demo.</em></span>:
      </p>
 
      <prototype text="Play" name="proof">
	<init_pointer></init_pointer>
	<run>
	  icon_bar("proof");
	</run>
	<ticker></ticker>
	<icon x="596" y="36" src="images/matrix_2.png" name="matrix"></icon>
	<icon x="596" y="100" src="images/axes.png" name="axes"></icon>
	<icon x="596" y="164" src="images/unit_vectors.png" name="unit_vectors"></icon>

	<pause delay="1500"></pause>
	<ticker>We start by setting up an unknown two by two matrix</ticker>
	<pause delay="1000"></pause>

	<select_icon name="matrix"></select_icon>
	<run>
	  var img = image("images/matrix_1.png", 10, 40);
	  img.id = "matrix1";
	  document.getElementById("prototype0").appendChild(img);
	</run>

	<pause delay="2000"></pause>
	<ticker>This creates a 2 by 2 matrix</ticker>

	<pause delay="2000"></pause>
	<ticker>We'll give the matrix a name, <em class="prototype_math">M</em></ticker>

	<pause delay="500"></pause>
	<move_mouse x="25" y="55"></move_mouse>

	<pause delay="250"></pause>
	
	<run>
	  document.getElementById("matrix1").style.display = "none";
	  animate_frames(
	   0, ["images/matrix2.png", "images/matrix3.png",
	       "images/matrix4.png", "images/matrix5.png"], [800, 800, 800, 0], 10, 40);
	</run>
	
	<pause delay="3500"></pause>
	<ticker>Then display a set of axes</ticker>
	<pause delay="1000"></pause>
	
	<select_icon name="axes"></select_icon>

	<run>
          plot_axes("proof")
	</run>

	<pause delay="2000"></pause>
	<ticker>Next, plot all the unit vectors</ticker>
	<pause delay="500"></pause>
	
	<select_icon name="unit_vectors"></select_icon>

	<run>
	  var ctx = document.getElementById("proof").getContext("2d");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	</run>

	<pause delay="2000"></pause>
	<ticker>Apply the matrix to the unit vectors</ticker>
	<pause delay="500"></pause>

	<move_mouse x="30" y="60"></move_mouse>
	<pause delay="250"></pause>
	<change_mouse_pointer name="images/matrix_mouse_pointer.png" x="10" y="40"></change_mouse_pointer>
	
	<move_mouse x="190" y="130" interrupt="96">
	  var ctx = document.getElementById("proof").getContext("2d");
	  ctx.clear();
	  ctx.filledRectangle(596, 0, 660, 400, "#ddd", "#ddd", 0);
	  plot_axes("proof");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), "yellow", 6);
	</move_mouse>

	<pause delay="400"></pause>

	<change_mouse_pointer name="images/cursor.png" x="205" y="145"></change_mouse_pointer>

	<run>
	  var ctx = document.getElementById("proof").getContext("2d");
	  ctx.clear();
	  ctx.filledRectangle(596, 0, 660, 400, "#ddd", "#ddd", 0);
	  plot_axes("proof");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	  plot_image("proof");
	</run>

	<pause delay="500"></pause>

	<ticker>The orange curve shows <em class="prototype_math">Ms</em> for all unit vectors <em class="prototype_math">s</em></ticker>
	
	<pause delay="3000"></pause>

	<ticker>We'll talk about this curve quite a bit, so we'll give it a name</ticker>
	<pause delay="4000"></pause>

	<ticker>We'll call it the <em>image of the unit circle</em> or just the <em>image curve</em></ticker>
	<pause delay="4000"></pause>
	
	  
	<ticker>Pick out the unit
	vector <em class="prototype_math">s</em> which becomes the
	longest</ticker>
	<pause delay="4000"></pause>
	<ticker>We will call <em class="prototype_math">s</em>
	the <em>principal right singular vector</em></ticker>
	<pause delay="5000"></pause>
	<ticker>The reason for the name will become apparent later</ticker>
	<pause delay="4000"></pause>
	<move_mouse x="30" y="60"></move_mouse>
	<run>
	  var img = image("images/prsv_menu_1.png", 35, 62);
	  img.id = "prsv_menu_1";
	  document.getElementById("prototype0").appendChild(img);
	</run>
	<pause delay="300"></pause>
	<move_mouse x="55" y="75" interrupt="20">
	  deleteElement(document.getElementById("prsv_menu_1"));
	  var img2 = image("images/prsv_menu_2.png", 35, 62);
	  img2.id = "prsv_menu_2";
	  document.getElementById("prototype0").appendChild(img2);
	</move_mouse>
	<pause delay="2500"></pause>
	<run>
	  deleteElement(document.getElementById("prsv_menu_2"));
	</run>
	
	<text x="345" y="148"><em class="prototype_math">s</em></text>
	<text x="310" y="60"><em class="prototype_math">Ms</em></text>
	<run>
	  var ctx = document.getElementById("proof").getContext("2d");
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	</run>
	<pause delay="5000"></pause>

	<ticker>Notice that <em class="prototype_math">Ms</em> is, as expected, the longest vector on the image curve</ticker>
	<pause delay="5000"></pause>
	
	<ticker>Let's look at the tangent to the image curve at <em class="prototype_math">Ms</em></ticker>
	<move_mouse x="315" y="65"></move_mouse>
	<pause delay="300"></pause>
	<run>
	  var img1 = image("images/tangent_vector_menu_1.png", 320, 67);
	  img1.id = "tangent_vector_menu_1";
	  document.getElementById("prototype0").appendChild(img1);
	</run>
	<pause delay="300"></pause>
	<move_mouse x="350" y="75" interrupt="20">
	  deleteElement(document.getElementById("tangent_vector_menu_1"));
	  var img2 = image("images/tangent_vector_menu_2.png", 320, 67);
	  img2.id = "tangent_vector_menu_2";
	  document.getElementById("prototype0").appendChild(img2);
	</move_mouse>
	<pause delay="3000"></pause>
	<run>
	  deleteElement(document.getElementById("tangent_vector_menu_2"));
	  var ctx = document.getElementById("proof").getContext("2d");
	  ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]),
	    xs(Ms_vec[0]+Mt_vec[0]), ys(Ms_vec[1]+Mt_vec[1]), IMAGE_COLOR, 2);
	</run>
	<pause delay="5000"></pause>
	
	<ticker>Visually, it's plausible the tangent is orthogonal
	  to <em class="prototype_math">Ms</em> (tangent
	  &perp; <em class="prototype_math">Ms</em>)</ticker>
	<pause delay="4000"></pause>

	<ticker>What's more, the tangent <em>isn't</em> &perp; at most
	places on the image curve</ticker>
	<pause delay="6000"></pause>

	<ticker>So the tangent being &perp;
	  at <em class="prototype_math">Ms</em> is a special property
	  of <em class="prototype_math">Ms</em></ticker>
	<pause delay="5000"></pause>

	<ticker>Maybe that's useful for figuring out the maximal stretching</ticker>
	<pause delay="6000"></pause>

	<ticker>Let's make a conjecture:</ticker>
	<pause delay="2000"></pause>
	<text x="15" y="337"><strong>Conj:</strong> The tangent to the
	image curve at <em class="prototype_math">Ms</em> is
	orthogonal to <em class="prototype_math">Ms</em></text>
	<pause delay="7000"></pause>

	<ticker>Let's try to prove the tangent is orthogonal to <em class="prototype_math">Ms</em></ticker>
	<pause delay="5000"></pause>

	<ticker>To do this, suppose the tangent <em>isn't</em>
	orthogonal to <em class="prototype_math">Ms</em></ticker>
	<pause delay="5000"></pause>

	<ticker>We'll show this leads to a contradiction</ticker>
	<pause delay="4000"></pause>

	<ticker>And so conclude that the tangent must have been
	orthogonal to <em class="prototype_math">Ms</em></ticker>
	<pause delay="5000"></pause>

	<ticker>Okay, suppose the tangent has a component in the
	<em class="prototype_math">Ms</em> direction</ticker>
	<pause delay="3500"></pause>
	<move_mouse x="264" y="73"></move_mouse>
	<pause delay="500"></pause>
	<run>
	  var k = 0;
	  function animate_attempt() {
  	    var ctx = document.getElementById("proof").getContext("2d");
	    ctx.clear();
	    plot_axes("proof");
	    icon_bar("proof");
	    ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	    var Mt_interp = [(1-k/50)*Mt_vec[0] + (k/50)*Mt_fake_vec[0],
	                     (1-k/50)*Mt_vec[1] + (k/50)*Mt_fake_vec[1]];
	    plot_image_partial("proof", Mt_interp, k/50);
	    ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]), xs(Mt_interp[0]+Ms_vec[0]),
	      ys(Mt_interp[1]+Ms_vec[1]), IMAGE_COLOR, 2);
	    $("#pointer0").css("left", xs(Mt_interp[0]+Ms_vec[0])+"px").css(
	      "top", ys(Mt_interp[1]+Ms_vec[1])+"px");
	    if (k < 50) {
		    k++;
		    window.requestAnimationFrame(animate_attempt);
	    }
	 }
	 animate_attempt();
	</run>
	<init_pointer x="298" y="48"></init_pointer>
	
	<pause delay="5000"></pause>
	
	<ticker>We can see that there's a problem</ticker>
	<pause delay="3000"></pause>
	<ticker>Let's look at the image curve near but not at <em class="prototype_math">Ms</em></ticker>
	<pause delay="4000"></pause>

	<move_mouse x="310" y="88"></move_mouse>
	<kill_pointer></kill_pointer>
	<pause delay="500"></pause>
	<run>
	  var k = 0;
	  function run_along_curve() {
  	    var ctx = document.getElementById("proof").getContext("2d");
	    ctx.clear();
	    plot_axes("proof");
	    icon_bar("proof");
	    ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	    plot_image_partial("proof", Mt_fake_vec, 1);
	    var position = vector_image_partial(Mt_fake_vec, 1, 0.5*k/50);
	    ctx.arrow(xs(0), ys(0), xs(position[0]), ys(position[1]), IMAGE_COLOR, 1);
	    ctx.beginPath();
	    ctx.arc(xs(position[0]), ys(position[1]), 3, 2*Math.PI, false), 
	    ctx.fillStyle = '#555';
	    ctx.fill();
	    ctx.lineWidth = 0;
	    ctx.stroke();
	    if (k < 50) {
		    k++;
		    window.requestAnimationFrame(run_along_curve);
	    }
	  }
          run_along_curve();
	</run>
	<pause delay="2000"></pause>
	<ticker>Points on the image curve get further from the origin</ticker>
	<pause delay="4500"></pause>
	<init_pointer x="295" y="71"></init_pointer>
	<pause delay="500"></pause>
	
	<ticker>The reason is that we're moving further out in the
	direction of <em class="prototype_math">Ms</em></ticker>
	<pause delay="6000"></pause>
	
	
	<ticker>This shouldn't have been possible,
	since <em class="prototype_math">Ms</em> was the longest
	vector</ticker>
	<pause delay="5000"></pause>
	
	<ticker>And so our assumption that the tangent is not &perp;
	must have been wrong</ticker>
	<pause delay="5000"></pause>

	<ticker>And so the conjecture is true</ticker>
	<pause delay="4000"></pause>

	<ticker>Of course, we need to fill some steps in to rigorously
	  prove this</ticker>
	<pause delay="5000"></pause>
	
	<ticker>We'll do that shortly</ticker>
	<pause delay="3000"></pause>

	<ticker>But that's the core idea</ticker>
	<pause delay="4000"></pause>
	
      </prototype>

      <p>
	Let's fill in the steps skipped above, to take the proof of
	the conjecture from geometric idea to rigorous proof.  Let $T$
	be the tangent vector at $Ms$.  We're assuming $T$ has a
	component in the direction of $Ms$, that is, $Ms \cdot T > 0$.
	Because $T$ is the tangent to the image curve, vectors on the
	image curve near $Ms$ can be written as $Ms+\Delta T +
	O(\Delta^2)$ for some small parameter $\Delta$.  The squared
	length of that vector on the image curve is:
      </p>

      <p>
	$$\|Ms+\Delta T + O(\Delta^2)\|^2 = \|Ms\|^2+ 2 \Delta \, Ms
	\cdot T + O(\Delta^2)$$
      </p>
      
      <p>
	But $Ms \cdot T > 0$, so for small $\Delta$ we have
	$\|Ms+\Delta T + O(\Delta^2)\|^2 > \|Ms\|^2$, i.e., moving
	along the image curve does, indeed, give us a vector longer
	than $Ms$.  That's a rigorous proof of what we wanted to show.
      </p>


      <p>
	We learned from the above explorations that the tangent to the
	image curve at $Ms$ is orthogonal to $Ms$.  We can make this
	observation more explicit by expressing the tangent $T$ in
	terms of existing quantities like $M$ and $s$.  To do this,
	recall that the image curve arose by applying $M$ to the unit
	circle.  It should be plausible that the tangent to the image
	curve at $Ms$ is just $Mt$ where $t$ is the tangent to the
	unit circle at $s$.  This can be proved with a tiny bit of
	calculus*<span class="marginnote">* I won't go through the
	details, though it's a good exercise if it's not immediately
	obvious.  Incidentally, this is standard calculus, and could
	easily be something the medium automatically
	&ldquo;knows&rdquo;, and suggests to the user through the
	interface.</span>.  It's easiest to see the situation through
	an illustration:
      </p>

      <prototype static="true" name="tangents">
	<run>
  	  var ctx = document.getElementById("tangents").getContext("2d");
          plot_axes("tangents");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(s_vec[0]), ys(s_vec[1]),
	    xs(s_vec[0]+t_vec[0]), ys(s_vec[1]+t_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	  plot_image("tangents");
	  ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]),
	    xs(Ms_vec[0]+Mt_vec[0]), ys(Ms_vec[1]+Mt_vec[1]), IMAGE_COLOR, 2);
	</run>
	<text x="345" y="148"><em class="prototype_math">s</em></text>
	<text x="315" y="70"><em class="prototype_math">Ms</em></text>
	<text x="303" y="108"><em class="prototype_math">t</em></text>
	<text x="235" y="60"><em class="prototype_math">Mt</em></text>

      </prototype>

      
      <p>
	We can make things even more explicit, noting that the tangent
	$t$ is orthogonal to $s$, since it's the tangent to a circle.
	And so the previous observation that the tangent to the image
	curve at $Ms$ is orthogonal to $Ms$ can be rewritten as:
      </p>

      <p>
	<strong>Lemma:</strong> <em>Let $s$ be the principal right
	singular vector of $M$, and let $t$ be orthonormal to $s$.
	Then $Ms$ is orthogonal to $Mt$.</em>
      </p>

      <p>
	The lemma tells us that the principal right singular vector
	$s$ is a very special vector.  For orthonormal vectors $s$ and
	$t$ it usually is <em>not</em> the case that $Ms$ is
	orthonormal to $Mt$.  What we learn from the lemma is that
	this is, however, true for the principal right singular
	vector.  That's a powerful thing to know.
      </p>

      <p>
	In fact, it actually lets us prove the SVD for $2 \times 2$
	matrices.  Let's use the lemma to explicitly construct each of
	the rotation-rescaling-rotation steps, in terms of $s, t, Ms$
	and $Mt$.  As before press &ldquo;Play&rdquo; on the demo
	below.  Note that this is no longer intended to represent a
	prototype cognitive medium, for reasons that will become
	apparent later.  Note also that I've moved $t$ and $Mt$ to the
	origin, emphasizing that $t$ is orthogonal to $s$, and $Mt$ is
	orthogonal to $Ms$.
      </p>

      <prototype text="Play" name="see_svd">

	<comment>Initial setup</comment>
	<ticker></ticker>
	<run>
	  var ctx = document.getElementById("see_svd").getContext("2d");
	  plot_axes("see_svd");
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(t_vec[0]), ys(t_vec[1]), UNIT_COLOR, 2);
	</run>
	<text x="345" y="148"><em class="prototype_math">s</em></text>
	<text x="219" y="118"><em class="prototype_math">t</em></text>

	<ticker>Let's consider <em class="prototype_math">s</em>
	and <em class="prototype_math">t</em></ticker>
	<pause delay="3000"></pause>

	<ticker>Goal:
	rotate-rescale-rotate <em class="prototype_math">s</em>
	and <em class="prototype_math">t</em> to get
	to <em class="prototype_math">Ms</em>
	and <em class="prototype_math">Mt</em></ticker>
	<pause delay="5000"></pause>
	<run>
	  var ctx = document.getElementById("see_svd").getContext("2d");
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Mt_vec[0]), ys(Mt_vec[1]), IMAGE_COLOR, 2);
	</run>
	<text x="300" y="60"><em class="prototype_math">Ms</em></text>
	<text x="200" y="176"><em class="prototype_math">Mt</em></text>
	<pause delay="5000"></pause>

	<ticker>To explain the operations, we'll focus
	on <em class="prototype_math">s</em>
	and <em class="prototype_math">t</em>
	</ticker>
	<pause delay="4500"></pause>

	<ticker>We'll ghost <em class="prototype_math">Ms</em>
	and <em class="prototype_math">Mt</em> out</ticker>
	<pause delay="4000"></pause>

	<run>
	  var ctx = document.getElementById("see_svd").getContext("2d");
	  ctx.clear();
	  plot_axes("see_svd");
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(t_vec[0]), ys(t_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 0.5);
	  ctx.arrow(xs(0), ys(0), xs(Mt_vec[0]), ys(Mt_vec[1]), IMAGE_COLOR, 0.5);
	</run>
	<text x="345" y="148"><em class="prototype_math">s</em></text>
	<text x="219" y="118"><em class="prototype_math">t</em></text>
	<text x="300" y="60"><em class="prototype_math ghost">Ms</em></text>
	<text x="200" y="176"><em class="prototype_math ghost">Mt</em></text>
	<pause delay="3000"></pause>

	<ticker>But leave slightly visible as reminder of goals
	  for <em class="prototype_math">s</em>
	  and <em class="prototype_math">t</em></ticker>
	<pause delay="5000"></pause>
	
	<comment>First rotation</comment>
	<ticker>We start by rotating <em class="prototype_math">s</em>
	and
	  <em class="prototype_math">t</em> to the co-ordinate
	  axes</ticker>
	<pause delay="4000"></pause>
	<comment>A crude hack to hide the labels</comment>
	<text x="345" y="148"><em class="prototype_math" style="color: #eee">s</em></text>
	<text x="219" y="118"><em class="prototype_math" style="color: #eee">t</em></text>
	<pause delay="1000"></pause>
	<run>
	  var theta = 0.0;
	  function plot_rotation_1() {
	    var ctx = document.getElementById("see_svd").getContext("2d");
	    ctx.clear();
	    plot_axes("see_svd");
	    var rot = [[Math.cos(theta), -Math.sin(theta)], [Math.sin(theta), Math.cos(theta)]];
	    var s_rot_vec = m_times_v(rot, s_vec);
	    var t_rot_vec = m_times_v(rot, t_vec);
	    theta -= 0.003;
	    ctx.arrow(xs(0), ys(0), xs(s_rot_vec[0]), ys(s_rot_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(t_rot_vec[0]), ys(t_rot_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 0.7);
	    ctx.arrow(xs(0), ys(0), xs(Mt_vec[0]), ys(Mt_vec[1]), IMAGE_COLOR, 0.7);
            if (theta > -phi) {window.requestAnimationFrame(plot_rotation_1)};
          }
	  plot_rotation_1();
	</run>
	<pause delay="4500"></pause>

	<ticker>We can do this
	because <em class="prototype_math">s</em>
	and <em class="prototype_math">t</em> are orthonormal</ticker>
	<pause delay="4000"></pause>

	<ticker>Rescale axes by factors $\|Ms\|$ and $\|Mt\|$</ticker>
	<pause delay="2000"></pause>
	<run>
          var Ms_length = length_vec(Ms_vec);
	  var Mt_length = length_vec(Mt_vec);

	  function interpolate(k, len) {
	    return (k/100.0) * len + (1-k/100.0) * 1.0;
	  }
	  
	  function rescale(k) {
	    // k will vary from 0 to 100
	    var ctx = document.getElementById("see_svd").getContext("2d");
	    ctx.clear();
	    plot_axes("see_svd");
	    var e1_rescale = [interpolate(k, Ms_length), 0];
	    var e2_rescale = [0, interpolate(k, Mt_length)];
	    ctx.arrow(xs(0), ys(0), xs(e1_rescale[0]), ys(e1_rescale[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(e2_rescale[0]), ys(e2_rescale[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 0.7);
	    ctx.arrow(xs(0), ys(0), xs(Mt_vec[0]), ys(Mt_vec[1]), IMAGE_COLOR, 0.7);
            if (k < 100) {
              window.requestAnimationFrame(function() {rescale(k+1)})
		    };
          }
	  rescale(0);
	</run>
	<pause delay="4500"></pause>

	<ticker>This leaves the rescaled vectors the &ldquo;right&rdquo; lengths, $\|Ms\|$ and $\|Mt\|$</ticker>
	<pause delay="5000"></pause>
	
	<ticker>Rotate rescaled axes
	to <em class="prototype_math">Ms</em>
	and <em class="prototype_math">Mt</em></ticker>
	<run>
          var Ms_length = length_vec(Ms_vec);
	  var Mt_length = length_vec(Mt_vec);

	  var theta = 0.0;
	  function plot_rotation_2() {
	    var ctx = document.getElementById("see_svd").getContext("2d");
	    ctx.clear();
	    plot_axes("see_svd");
	    var rot = [[Math.cos(theta), -Math.sin(theta)], [Math.sin(theta), Math.cos(theta)]];
	    var e1_rescale = [Ms_length, 0];
	    var e2_rescale = [0, Mt_length];
	    var e1_rot_vec = m_times_v(rot, e1_rescale);
	    var e2_rot_vec = m_times_v(rot, e2_rescale);
	    theta += 0.005;
	    ctx.arrow(xs(0), ys(0), xs(e1_rot_vec[0]), ys(e1_rot_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(e2_rot_vec[0]), ys(e2_rot_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 0.5);
	    ctx.arrow(xs(0), ys(0), xs(Mt_vec[0]), ys(Mt_vec[1]), IMAGE_COLOR, 0.5);
            if (theta < psi) {window.requestAnimationFrame(plot_rotation_2)};
          }
	  plot_rotation_2();

	</run>
	<pause delay="6000"></pause>
	
	<ticker>We can do this
	because <em class="prototype_math">Ms</em>
	&#8869; <em class="prototype_math">Mt</em></ticker>
	<pause delay="5000"></pause>

	<ticker>The net effect is to
	take <em class="prototype_math">s</em>
	to <em class="prototype_math">Ms</em> and
	  <em class="prototype_math">t</em>
	  to <em class="prototype_math">Mt</em>, as desired</ticker>
	<pause delay="5000"></pause>

	<ticker>It may help to rewatch this to grok all the
	operations</ticker>
	<pause delay="5000"></pause>
	
      </prototype>

      <p>
        To recap, we rotate the principal right singular vector $s$ to
        the first co-ordinate axis.  This rotation automatically
        rotates the vector $t$ (which is orthonormal to $s$) to the
        second co-ordinate axis.  We then rescale the first
        co-ordinate axis by a factor $\|Ms\|$, and the second
        co-ordinate axis by a factor $\|Mt\|$.  And finally we rotate
        the rescaled vectors to $Ms$ and $Mt$.  This last step makes
        crucial use of the lemma, since it's only possible because
        $Ms$ and $Mt$ are orthogonal.
      </p>

      <p>
	By construction, this rotation-rescaling-rotation combination
	takes $s$ to $Ms$ and $t$ to $Mt$.  In fact, it follows that
	the rotation-rescaling-rotation combination must do the same
	as $M$ for <em>all</em> possible inputs.  The reason is that
	$s$ and $t$ form a basis for the vector space, and since both
	$M$ and the rotation-rescaling-rotation act linearly on
	vectors, $M$ and the rotation-rescaling-rotation have the same
	action on <em>all</em> vectors.  Thus, $M$ is equal to the
	rotation-rescaling-rotation operation.  And so we've proved
	the singular value decomposition for $2 \times 2$ matrices.
      </p>

      <p>
	Well, that's pretty nice!  We started out with a question
	about how much a matrix stretches space, and the singular
	value decomposition more or less dropped out of our
	exploration.  In fact, while our proof of the SVD was in $2$
	dimensions, the proof is easily extended to $n$ dimensions.
	That generalization is incidental to the main point of this
	essay, so I've sketched it out in <a href="#appA">Appendix
	A</a>.
      </p>

      <p>
	An interesting aspect of the discussion so far is that we
	actually <em>haven't</em> solved our original problem: to
	figure out the maximal degree of stretching.  This mirrors
	what often happens in real mathematical work &ndash; you may
	not solve the problem you originally intended to solve, but
	you learn something interesting anyway!  In fact, it's
	possible to use the SVD to solve our original problem, finding
	the maximal stretching.  Again, this is incidental to the main
	point of this essay, and so I describe how to do it
	in <a href="#appB">Appendix B</a>.
      </p>

      <p>
	<h2>Semi-concrete reasoning</h2>
      </p>

      <p>
	I glossed over a very interesting moment in our proof of the
	SVD.  It's the point where we ask what happens if the tangent
	vector has a component in the direction of $Ms$.  Let me
	remind you what happens.  It takes just a few seconds:
      </p>

      <p>
	<em>XXX --- video excerpt from the earlier demo, showing the
	moment at which we click-and-drag on the tangent, and the
	corresponding adjustment of the image curve.</em>
      </p>

      <p>
	This appears simple and natural.  It's the kind of thing a
	mathematician working with paper-and-pencil does almost
	without thinking.  But in a computer-based medium, something
	sophisticated must be going on under the hood.  To understand
	why, let's think about how the medium would model the actions
	shown.  A natural approach is to start with a matrix $M$ which
	has some generic values filled in.  In fact, the values for
	$s, t, Ms$ <em>etcetera</em> shown above are produced by the
	following matrix $M$:
      </p>

      <p>
      $$M = \begin{bmatrix} 0.70 & -0.28 \\ 1.27 & 0.86 \end{bmatrix} $$
      </p>

      <p>
	So, for example, the image curve is computed by applying this
	particular $M$ to the points making up the unit circle.  And
	the principal right singular vector $s$ is computed from this
	$M$.  And so on, for all the properties computed by the
	medium.
      </p>

      <p>
	In using this specific $M$ we're following a time-honored
	mathematical tradition: in order to reason about some general
	class of objects &ndash; in this case, all the $2 \times 2$
	matrices &ndash; our medium has picked out one particular $2
	\times 2$ matrix, and is using it as a generic example.  The
	benefit of doing this is that it lets the medium do all
	computations explicitly, so we can reason from concrete,
	easily-understood and visualized examples.  So, for instance,
	using a concrete example makes it easy to notice that the
	tangent to the image curve at $Ms$ is orthogonal to $Ms$, when
	$s$ is the principal right singular vector.  Of course, the
	medium only shows this for this specific matrix $M$.  But the
	fact that the example matrix $M$ is generic makes it plausible
	that this phenomenon holds for any $2 \times 2$ matrix.
	Indeed, it would be easy to check for other choices of $M$,
	though I didn't explicitly show that happening.  This practice
	of using concrete-but-generic examples to gain insight has
	been common practice all through mathematical history, but is
	made especially easy with digital
	computers*<span class="marginnote">* There's an art to picking
	out generic examples that don't mislead.  That's not a problem
	I'm going to discuss in detail, but it's a fascinating
	subject.  To develop a good concrete medium for doing
	mathematics, I suspect it's a subject which would need to be
	investigated in great depth.  Incidentally, in his
	essay <a href="http://worrydream.com/LadderOfAbstraction/">Up
	and Down the Ladder of Abstraction</a>, Bret Victor has
	explored a powerful approach whereby it's sometimes possible
	to eschew generic examples, and instead work with concrete
	visualizations representing the space of all
	examples. </span>.
      </p> 

      <p>
	Now, what happens when we drag the tangent away from its
	actual value to a value not orthogonal to $Ms$, as shown in
	the video just above?
      </p>

      <p>
	Before the change the medium was keeping track of the
	following mathematical objects:
      </p>
      
      <p>
	<pre>
M:  a 2 by 2 matrix, with entries 0.70, -0.28, ...
The unit circle
The image of the unit circle under M
s:  the principal right singular vector, with entries 0.89, 0.46
Ms: the result of applying M to s, with entries 0.49, 1.52
The tangent to the image curve at Ms, with entries -0.57, 0.18
	</pre>
      </p>

      <p>
	What happens to the internal state of the medium when we
	change the tangent?  Of course, our internal representation of
	the tangent must change.  But there are challenges in updating
	our description of the other objects.  Most glaringly, no
	matrix $M$ exists which has the desired values for $Ms$ and
	the changed tangent.
      </p>

      <p>
	One natural response is to declare the value of $M$ to
	be <code>undefined</code>.  If we do that, then it's also
	natural to declare $s$, the principal right singular vector of
	$M$, as <code>undefined</code>.  Ditto the image curve.  Our
	mathematical objects are all vanishing!  We started with the
	idea of computing everything from underlying concrete objects.
	That's difficult to do when our objects no longer exist.
      </p>

      <p>
	The problem is that we're trying to describe an impossible
	world.  There is no consistent set of mathematical objects
	that satisfies all the constraints we've imposed in our
	system.  And yet despite this inconsistency, we'd like to
	continue reasoning.  After all, a mathematician working with
	pencil-and-paper has no trouble continuing at this point.  The
	reason this is possible is that a static medium like
	paper-and-pencil does no computation or constraint-checking.
	The medium doesn't tell us it's not possible to edit
      </p>

      <img src="images/paper1.jpg"/>

      <p>
	erasing and modifying the tangent and image curve so the image becomes
      </p>


      <img src="images/paper2.jpg"/>

      <p>
	This is despite the fact that there is no matrix $M$ having
	the depicted values.
      </p>

      <p>
	This lack of constraint checking is both a feature and a bug.
	Because paper-and-pencil doesn't enforce this kind of
	constraint checking, it relies on the mathematician to do the
	constraint-checking in their head in a principled
	way*<span class="marginnote">* In this, it's much like the way
	weakly-typed programming languages rely on programmers to be
	careful about what gets passed to a function.  I suspect the
	right answer to the question &ldquo;Should my language be
	strong or weakly typed?&rdquo; is &ldquo;Both!&rdquo;.</span>.
	That's a substantial cognitive burden.  But it also gives the
	mathematician a lot of freedom to carry out counterfactual
	reasoning, like we did in the last section.
      </p>

      <p>
	One possible response is to puritanically say &ldquo;Oh, well,
	we shouldn't do this kind of reasoning in our medium&rdquo;.
	While that would be convenient, it'd be burying our head in
	the sand.  Real mathematicians engage in this kind of
	counterfactual reasoning all the time.  They're happy to
	imagine impossible worlds <em>en passant</em>, and to make
	progress by asking &ldquo;What would happen if this world
	actually existed?&rdquo;
      </p>


      <p>
	Systems for doing mathematics by computer, such as Matlab and
	Mathematica, are often terrific at doing computations with
	concrete objects.  They can verify in a flash that $Ms$ is
	orthogonal to $Mt$ for any specific choice of matrix $M$.  But
	they don't always make it easy to do counterfactual reasoning.
	You can't easily ask Matlab to suppose that $Ms$ is not
	orthogonal to $Mt$.  And this actually makes it harder to
	prove that $Ms$ is always orthogonal to $Mt$, for any $2
	\times 2$ matrix $M$.  If we make counterfactual reasoning
	difficult, then we greatly weaken our medium of discovery.
      </p>

      <p>
	What we'd ideally like is a medium supporting what we shall
	call <em>semi-concrete reasoning</em>.  It would
	simultaneously provide: (1) the ability to compute concretely,
	to apply constraints, and to make inferences, i.e., all the
	benefits we expect a digital computer to apply (and which made
	it so easy to notice that $Ms$ is orthogonal to the tangent in
	the first place); and (2) the benefits of paper-and-pencil,
	notably the flexibility to explore and make inferences about
	impossible worlds.  As we've seen, there is tension between
	these two requirements.  Yet is is highly desirable that both
	be satisifed simultaneously if we are to build a powerful
	exploratory medium for doing mathematics.  That is true not
	just in the medium I have described, but in any exploratory
	medium.
      </p>

      <p>
	In the next section I sketch an approach to building a system
	for semi-concrete reasoning.  We shall see that this is a
	challenging problem, with open-ended components involving the
	psychology of the user, and what constitutes
	&ldquo;natural&rdquo; modes of mathematical inference.  We
	won't completely solve the problem.  But we will at least
	better understand some of the principles to be followed in any
	system for semi-concrete reasoning.
      </p>


      <h3>
	Principles of semi-concrete reasoning
      </h3>

      <p>
	In our earlier discussion, we implicitly assumed our medium
	has an internal data model that represents mathematical
	reality.  In particular, having updated the value for the
	tangent, we assumed it was the job of the medium to find a
	corresponding consistent value for $M$ and for other
	quantities in the problem.
      </p>

      <p>
	It's possible to proceed in a different fashion.  Instead of
	using our medium's data model to represent mathematical
	reality, we can instead <em>use the medium's data model to
	represent the user's current state of mathematical
	knowledge</em>.  This makes sense, since in an exploratory
	medium we are not trying to describe what is true &ndash; by
	assumption, we don't know that, and are trying to figure it
	out &ndash; but rather what the user currently knows, and how
	to best support further inference.
      </p>

      <p>
	Having adopted this point of view, user interface operations
	correspond to changes in the user's state of mathematical
	knowledge, and thus also make changes in the medium's model of
	that state.  There is no problem with inconsistency, because
	the medium's job is only to model the user's current state of
	knowledge, and that state of knowledge may well be
	inconsistent.  In a sense, we're actually asking the computer
	to do less, at least in some ways, by ignoring constraints.
	And that makes for a more powerful medium.
      </p>

      <p>
	Having adopted this point of view, the question is how the
	medium can best support the user's mathematical exploration
	and further inference.  The simplest approach is to allow the
	user to manually edit the mathematical world, with little
	assistance from the computer in doing inference:
      </p>

      <prototype text="Play" name="simple_edit">
	<init_pointer></init_pointer>
	<ticker></ticker>
	<icon x="596" y="30" src="images/matrix_2.png" name="matrix"></icon>
	<icon x="596" y="94" src="images/axes.png" name="axes"></icon>
	<icon x="596" y="158" src="images/unit_vectors.png" name="unit_vectors"></icon>
	<icon x="596" y="222" src="images/prsv.png" name="prsv"></icon>
	<icon x="596" y="286" src="images/orthogonal_icon.png" name="orthogonal"></icon>

	<run>
	  var ctx = document.getElementById("simple_edit").getContext("2d");
          plot_axes("simple_edit")
 	  icon_bar("simple_edit");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	  ctx.filledRectangle(596, 0, 660, 400, "#ddd", "#ddd", 0);
	  plot_image("simple_edit");
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	  ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]),
	  xs(Ms_vec[0]+Mt_vec[0]), ys(Ms_vec[1]+Mt_vec[1]), IMAGE_COLOR, 2);
	</run>
	<text x="345" y="148"><em class="prototype_math">s</em></text>
	<text x="310" y="65"><em class="prototype_math">Ms</em></text>
	<text x="15" y="337"><strong>Conj:</strong> The tangent
	at <em class="prototype_math">Ms</em> is $\perp$ to
	  <em class="prototype_math">Ms</em></text>

	<ticker>Let's click and drag the tangent vector</ticker>
	<pause delay="2000"></pause>
	<move_mouse x="264" y="73"></move_mouse>
	<pause delay="500"></pause>
	<run>
	  var k = 0;
	  function animate_attempt() {
  	    var ctx = document.getElementById("simple_edit").getContext("2d");
	    ctx.clear();
	    icon_bar("simple_edit");
	    plot_axes("simple_edit");
	    ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	    plot_image("simple_edit");
	    ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	    var Mt_interp = [(1-k/50)*Mt_vec[0] + (k/50)*Mt_fake_vec[0] + Ms_vec[0],
	                     (1-k/50)*Mt_vec[1] + (k/50)*Mt_fake_vec[1] + Ms_vec[1]];
	    ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]), xs(Mt_interp[0]), ys(Mt_interp[1]), IMAGE_COLOR, 2);
	    $("#pointer3").css("left", xs(Mt_interp[0])+"px").css("top", ys(Mt_interp[1])+"px");
	    if (k < 50) {
		    k++;
		    window.requestAnimationFrame(animate_attempt);
	    }
	  }
	  animate_attempt();
	</run>
	<init_pointer x="298" y="48"></init_pointer>
	
	<pause delay="2000"></pause>
	<ticker>Then select and delete the image curve</ticker>
	<pause delay="2000"></pause>
	<move_mouse x="283" y="96" interrupt="95">
	  plot_image("simple_edit", 6, "yellow");
	</move_mouse>
	<pause delay="1000"></pause>
	<run>
  	    var ctx = document.getElementById("simple_edit").getContext("2d");
	    ctx.clear();
	    icon_bar("simple_edit");
	    plot_axes("simple_edit");
	    ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	    ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	    var Mt_interp = [(1-k/50)*Mt_vec[0] + (k/50)*Mt_fake_vec[0] + Ms_vec[0],
	                     (1-k/50)*Mt_vec[1] + (k/50)*Mt_fake_vec[1] + Ms_vec[1]];
	    ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]), xs(Ms_vec[0]+Mt_fake_vec[0]),
	      ys(Ms_vec[1]+Mt_fake_vec[1]), IMAGE_COLOR, 2);
	</run>
	<pause delay="500"></pause>
	<ticker>Then sketch in the modified image curve</ticker>
	<pause delay="500"></pause>
	<move_mouse x="295" y="71"></move_mouse>
	<pause delay="500"></pause>
	<run>
	  var ctx = document.getElementById("simple_edit").getContext("2d");
	  var theta = 0.6;
	  var start = vector_image_partial(Mt_fake_vec, 1, theta);
	  var next;
	  function nextArcStep() {
	    theta += -0.01;
	    next = vector_image_partial(Mt_fake_vec, 1, theta);
	  $("#pointer3").css("left", xs(next[0])+"px").css("top", ys(next[1])+"px");
	    ctx.line(xs(start[0]), ys(start[1]), xs(next[0]), ys(next[1]), IMAGE_COLOR);
	    if (theta > -0.6) {
	      start = next;
	      requestAnimationFrame(nextArcStep)
	    }
	  }
	  nextArcStep();
	</run>
	<pause delay="3000"></pause>
      </prototype>

      <p>
	This sequence of operations corresponds roughly to the
	operations performed by a human mathematician with
	paper-and-pencil.  The internal state of the medium after
	these operations would be:
      </p>

      <p>
	<pre>
M:  a 2 by 2 matrix, with entries 0.70, -0.28, ...
The unit circle
The edited image curve
s:  the principal right singular vector, with entries 0.89, 0.46
Ms: the result of applying M to s, with entries 0.49, 1.52
The edited tangent to the image curve at Ms, with entries -0.15, 0.5
	</pre>
      </p>

      <p>
	This is not a consistent mathematical world.  It doesn't need
	to be, since the purpose of our medium's data model is no
	longer to represent a consistent mathematical world, but to
	represent the user's current state of mathematical knowledge,
	and to support further inference.
      </p>

      <p>
	Of course, it's disappointing to require the user to make all
	inferences manually, as they would with paper-and-pencil.
	Ideally, an exploratory medium would help the user make
	inferences, give the user control over how these inferences
	are made, and make it easy for the user to understand and
	track the chain of reasoning.  To appreciate the importance of
	these principles, consider the following medium:
      </p>

      <prototype text="Play" name="illegible_edit">
	<init_pointer></init_pointer>
	<ticker></ticker>
	<icon x="596" y="30" src="images/matrix_2.png" name="matrix"></icon>
	<icon x="596" y="94" src="images/axes.png" name="axes"></icon>
	<icon x="596" y="158" src="images/unit_vectors.png" name="unit_vectors"></icon>
	<icon x="596" y="222" src="images/prsv.png" name="prsv"></icon>
	<icon x="596" y="286" src="images/orthogonal_icon.png" name="orthogonal"></icon>

	<run>
	  var ctx = document.getElementById("illegible_edit").getContext("2d");
          plot_axes("illegible_edit")
 	  icon_bar("illegible_edit");
	  ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	  ctx.filledRectangle(596, 0, 660, 400, "#ddd", "#ddd", 0);
	  plot_image("illegible_edit");
	  ctx.arrow(xs(0), ys(0), xs(s_vec[0]), ys(s_vec[1]), UNIT_COLOR, 2);
	  ctx.arrow(xs(0), ys(0), xs(Ms_vec[0]), ys(Ms_vec[1]), IMAGE_COLOR, 2);
	  ctx.arrow(xs(Ms_vec[0]), ys(Ms_vec[1]),
	  xs(Ms_vec[0]+Mt_vec[0]), ys(Ms_vec[1]+Mt_vec[1]), IMAGE_COLOR, 2);
	</run>
	<text x="346" y="150" id="s_swinging"><em class="prototype_math">s</em></text>
	<text x="310" y="65" id="Ms_swinging"><em class="prototype_math">Ms</em></text>

	<ticker>Let's try clicking and dragging the tangent vector again</ticker>
	<pause delay="3000"></pause>
	<move_mouse x="264" y="73"></move_mouse>
	<pause delay="500"></pause>
	<comment>
	  Let me explain the mathematics here, so this is
	  understandable later.

	  We'll move the mouse pointer exactly as before, defining a
	  vector which we'll call interp.  In previous widgets this
	  was called Mt_interp, but we rename since it can't really be
	  understood in terms of an interpolated (and displaced) Mt.

	  What we want is to find a unit vector sp (for s prime) such
	  that:

	  interp - M sp is tangent to M sp on the image curve

	  For this to be the case, we must have

	  interp - M sp proportional to M sp_perp,

	  where sp_perp is the tangent to sp on the unit circle.  We
	  can rewrite this as:

	  interp - M sp = c M sp_perp

	  for some constant c.  Multiplying by M^{-1} and taking
	  inner products we have:

	  M^{-1} interp . sp = 1

	  M^{-1} interp . sp_perp = c

	  And so 1+c^2 = ||M^{-1} interp||^2

	  We can solve for c:

	  c = pm sqrt(||M^{-1} interp||^2-1)

	  Thinking about the geometry of our situation, it should be
	  +.  Of course, in general we'd need to do a (rather
	  tedious!) case analysis.
	  
	  c = sqrt(||M^{-1} interp||^2-1)

	  Our earlier equation can also be written:

	  M^{-1} interp = (I+c F) sp

	  where F = [[0, -1], [1, 0]].

	  We can then use this to solve for sp:

	  c = sqrt{||M^{-1} interp||^2-1}

	  sp = (I+c F)^{-1} M^{-1} interp

	  These final two equations let us figure out a suitable value
	  for sp, and then for M sp.

	  There's a lot to do here.  But there's nothing difficult!
	</comment>
	<run>
	  var k = 0;
	  function animate_attempt_2() {
  	    var ctx = document.getElementById("illegible_edit").getContext("2d");
	    ctx.clear();
	    icon_bar("illegible_edit");
	    plot_axes("illegible_edit");
	    ctx.circle(xs(0), ys(0), xs(1)-xs(0), UNIT_COLOR, 2);
	    plot_image("illegible_edit");
	    var interp = [(1-k/50)*Mt_vec[0] + (k/50)*Mt_fake_vec[0] + Ms_vec[0],
	      (1-k/50)*Mt_vec[1] + (k/50)*Mt_fake_vec[1] + Ms_vec[1]];
	    var inverse_interp = m_times_v(matrix_inverse(M), interp);
	    var c = Math.sqrt(Math.pow(length(inverse_interp), 2)-1);
	    var temp = [[1, -c], [c, 1]];
	    var sp = m_times_v(matrix_inverse(temp), inverse_interp);
	    ctx.arrow(xs(0), ys(0), xs(sp[0]), ys(sp[1]), UNIT_COLOR, 2);
	    var M_sp = m_times_v(M, sp);
	    ctx.arrow(xs(0), ys(0), xs(M_sp[0]), ys(M_sp[1]), IMAGE_COLOR, 2);
	    ctx.arrow(xs(M_sp[0]), ys(M_sp[1]), xs(interp[0]), ys(interp[1]), IMAGE_COLOR, 2);
	    $("#pointer4").css("left", xs(interp[0])+"px").css("top", ys(interp[1])+"px");
	    $("#s_swinging").css("left", (xs(sp[0])+5)+"px").css("top", (ys(sp[1])-23)+"px");
	    $("#Ms_swinging").css("left", (xs(M_sp[0]))+"px").css("top", (ys(M_sp[1])-23)+"px");
	    if (k < 50) {
		    k++;
		    window.requestAnimationFrame(animate_attempt_2);
	    }
	  }
	  animate_attempt_2();
	</run>
	<pause delay="3000"></pause>
      </prototype>

      <p>
	In this medium, as we move the end of the tangent vector, the
	medium finds a new corresponding base point $Ms$ on the image
	curve.  It chooses the new base point so the tangent vector
	is, indeed, a genuine tangent to the image curve (which is
	presumed to be fixed).  At the same time, the medium also
	recomputes the value of $s$, by multiplying the new value for
	$Ms$ by $M^{-1}$.
      </p>
      
      <p>
	Now, in some proofs these may be exactly the desired
	inferential steps.  But upon deeper consideration, this
	example illustrates some genuine design challenges.  In
	particular, in general we'd like to use our medium to reason
	about a large number of mathematical objects.  There is
	potentially an exponentially large number of ways changing one
	object can cause inferred changes in others.  In order for the
	user to understand what is going on, the way inferred changes
	propagate needs to clearly communicated.  In particular, the
	medium must be designed so the user can easily navigate the
	many possible chains of inference.
      </p>

      <p>
	In paper-and-pencil mathematics, how we do inference depends
	upon what relationships we know between objects in the system.
	In this case, we know of just a single direct relationship
	between the tangent vector and other objects: the tangent is a
	function of the base point and the image
	curve*<span class="marginnote">* Note that later in the proof
	we learn that the tangent is equal to $Mt$.  That's a second
	important relationship.  However, I am speaking of what the
	user knows at the particular moment in time we're focused
	on.</span>:
      </p>

	<img src="images/input_output.png"/>

      <p>
	If we're using paper-and-pencil, we must use this relationship
	to deduce the implications of changing the tangent.  The
	reason is that it's the only relevant thing we know.
	Effectively, we're inverting the relationship:
      </p>

      <img src="images/input_output_inverted.png">

      <p>
	In this particular case, we want the base vector $Ms$ to
	remain unchanged, by assumption.  Given that, we can infer
	what the image curve &ldquo;must have been&rdquo;, given the
	modifed value for the tangent.  Of course, the modified image
	curve is not uniquely determined, and so with paper-and-pencil
	we sketch an illustrative curve segment.  That illustrative
	curve segment is <em>not</em> supposed to literally be the
	implied curve segment; rather, it is a curve segment with
	approximately the right shape, and where the base point and
	tangent are exactly correct.
      </p>
      
      <p>
	The paper-and-pencil reasoning is strikingly different to the
	earlier medium.  In that medium, changing the tangent vector
	caused an immedate change to $s$.  With paper-and-pencil any
	such inference would have required a two-step reasoning
	process: first, figure out what changing the tangent means for
	$Ms$, and then figure out what that change to $Ms$ means for
	$s$.
      </p>

      <p>
	We could adopt a similar single-step inference approach to our
	exploratory medium.  In such a medium, for every interface
	operation <em>generating</em> a new relationship between
	objects, there would be a corresponding interface operation
	enabling us to infer how changes in any one of those objects
	affects the other objects.  In the specific case we've been
	considering, this means the task of the medium is to present
	the user a way of selecting from amongst the space of base
	vectors and segments of image
	curves*<span class="marginnote">* A point I've glossed over is
	how the medium knows what shape to use for the curve segment.
	One possible answer is to interpolate based on the original
	curve and the modified tangent. This is the strategy I used in
	the prototype, and it seems to work reasonably well.</span>.
      </p>

      <img src="images/input_output_inverted.png">

      <p>
	With paper-and-pencil, this inversion needs to be performed
	mechanically.  In an exploratory medium, the medium itself can
	guide us in doing the inversion.  Of course, in this instance
	the inference isn't especially hard, so this is only a small
	win, but it nonetheless does help free the user to concentrate
	on higher-level reasoning.
      </p>

      <p>
	Using the medium to support only a single stage of inference
	has several benefits.  It naturally makes the chain of
	inference legible, since it mirrors the way we do inference
	with paper-and-pencil, every step made explicit, while
	reducing tedious computational work.  It's also natural
	psychologically, since the user is already thinking in terms
	of these relationships, having defined the objects this way.
	Finally, and perhaps most importantly, it limits the scope of
	the interface design problem, since we need not design
	separate interfaces for the possibly unlimited(!) number of
	possible inferences.  Rather, for every interface operation
	generating an object, we need to design an interface to
	propagate changes.  That's a challenging but finite design
	problem.  Indeed, in the worst case, a &ldquo;completely
	manual&rdquo; interface like that presented earlier may in
	general be used.
      </p>

      <p>
        With that said, one could imagine mediums which performs
        multiple stages of inference in a single step, such as our
        earlier medium modifying $s$ in response to changes in the
        tangent.  Designing such a medium would be much more
        challenging, since potentially many more relationships are
        involved (meaning more interfaces need to be exposed to the
        user), and it is also substantially harder to make the chain
        of reasoning legible to the user.
      </p>

      <p>
	Even with the simplification of doing single-step inference,
	there are still many challenging design problems to be solved.
	Most obviously, we've left open the problem of designing
	interfaces to support these single stages of inference.  We've
	seen two possible approaches for the particular case of
	relating the tangent to the base point and image curve.  In
	general, solving this interface design problem is an
	open-ended empirical and psychological question.  It's an
	empirical question insofar as different modes of inference may
	be useful in different mathematical proofs.  And it is a
	psychological question, insofar as different interfaces may be
	more or less natural for the user.  Every kind of relationship
	possible in the medium will require its own interface, and
	thus present a new design challenge.  The simplest way to meet
	that challenge is to use a default-to-manual-editing strategy,
	mirror paper-and-pencil.  But by providing additional
	inference options we can support more powerful reasoning, and
	strictly surpass paper-and-pencil.
      </p>

      <p>
	A second design problem is the profusion of possible ways in
	which inference may occur.  Later in the proof we connect the
	tangent not just to $Ms$ and the image curve, but also to
	$Mt$.  At that point the user would be aware of two seaprate
	direct relationships involving the tangent vector:
      </p>

      <img src="images/tangent_all_relationships.png">

      <p>
	The medium would then need to allow the user to make
	inferences about how changes to the tangent
	changed <em>either</em> $Mt$ <em>or</em> $Ms$ and the image
	curve.  In general, the medium needs to allow the user to make
	choices between <em>multiple types of inference</em> possible
	at any given stage.  This seems complex.  But it mirrors the
	complexity inherent in the problem.  The problem solver must
	make choices about how to investigate the effects of changes
	in assumption.  The medium is merely reifying the choices that
	have to be made to make those inferences.  The benefit of the
	medium is that it provides support to make those inferences
	and track their impact.
      </p>


      <p>
	<strong>Outlook:</strong> In discussions of systems of
	reasoning it is sometimes assumed that the informal, intuitive
	systems used by humans are things to be &ldquo;fixed
	up&rdquo;, turned into so-called proper, rigorous reasoning.
	If the purpose of reasoning is merely verifying correctness,
	then that may well be correct.  But if the purpose of
	reasoning is exploration and discovery, then it is wrong.
	Exploration and discovery require a logic that is different
	to, and at least as valuable, as conventionally
	&ldquo;correct&rdquo; reasoning*<span class="marginnote">*
	Related problems are addressed, using rather different ideas,
	by proof assistants such as Coq and Agda, constraint systems
	such as <a href="refs/Sutherland1963.pdf">Sketchpad</a> and
	its descendants, and by reasoning systems such as Prolog, Cyc
	and their descendants.</span>.  The idea of semi-concrete
	reasoning is a step toward media to support such exploration
	and discovery, and perhaps toward new ways of thinking about
	mathematics.
      </p>

      <p>
	<a href="refs/Kay2013.pdf">Alan Kay has asked</a> &ldquo;what
	is the carrying capacity for ideas of the computer?&rdquo; We
	may also ask the closely related question: &ldquo;what is the
	carrying capacity for <em>discovery</em> of the
	computer?&rdquo; In this essay we've made progress on that
	question using a simple strategy: develop a prototype medium
	to represent mathematics in a new way, and carefully observe
	what happens and what we can learn when we use the prototype
	to attack a serious mathematical problem.  In future, it'd be
	fruitful to pursue a similar strategy with other problems, and
	with more adventurous interface ideas.
      </p>

      <p>
	To conclude, a personal observation.  I began thinking
	seriously about the design of cognitive media just a few years
	ago.  This is my first essay on the subject.  I repeatedly
	discovered that interface design is deeper than I at first
	appreciated.  A powerful medium reifies the deepest ideas we
	have about a subject: it becomes an active carrier for those
	ideas.  And to the extent it is successful in reifying those
	ideas, mastering the medium becomes the same as mastering the
	subject.  In this view, designing exploratory media is about
	designing tools which can transform and extend our ability to
	think, create, and discover.
      </p>

      <p>
	<em>XXX: There's many ways one could go further.  Developing
	the reasoning system in detail -- the notion of developing a
	sort of type system to denote ontolological and
	epistemological status is particularly fun.  But I'm uncertain
	about doing this.  The results obtained are fun, but (at least
	so far) seem relatively minor.  Of course, if I pushed on to
	build a system that really implemented semi-concrete reasoning
	that'd be worth recounting in detail.  But I haven't done
	that, and it somehow seems like the wrong choice at this point
	in time.</em>
      </p>
	


      <p>
	<em><strong>Acknowledgements:</strong> Thanks to Dave Albert,
	  Darius Bacon, Kovas Boguta, Ilona Brand, Jesse Tasse
	  Gonzalez, Max McCrea, Prabhakar Ragde, Omar Rizwan, and John
	  Workman for comments that helped improve this essay.</em>
      </p>

	
      <p><a name="appA"></a>
	<h2>Appendix A: the proof of the SVD in $n$
	dimensions</h2>
      </p>

      <p>
	In the main body of the essay we learned how to prove the
	singular value decomposition in 2 dimensions.  In fact, the
	same ideas can be used to prove the SVD in $n$ dimensions.
	I'll briefly sketch how the proof works in this appendix.  It
	begins with exactly the same argument as we used earlier,
	showing that if $s$ is the principal right singular vector of
	$M$, and $t$ is any vector orthonormal to $s$, then $Ms$ is
	orthogonal to $Mt$.  No modification is needed to establish
	this &ndash; the proof goes straight through.
      </p>

      <p>
	From this, it can be shown using a construction similar to the
	$2 \times 2$ case that
      </p>

      <p>
	$$M = U_1 \begin{bmatrix} s_1 & 0 \\ 0 & M' \end{bmatrix} V_1$$
      </p>

      <p>
	where $U_1$ and $V_1$ are orthogonal matrices, and $M'$ is an
	$n-1$ by $n-1$ submatrix.  Proving this is pretty
	straightforward, although it may be tedious if you're not so
	comfortable with linear algebra.  The only real difference is
	that instead of working with a vector $t$ tangent to the
	principal right singular vector $s$, we instead work with the
	entire vector subspace tangent to $s$. I won't go through the
	details.
      </p>

      <p>
	We can repeat this decomposition, breaking $M'$ up in terms of
	orthogonal matrices in $n-1$ dimensions and an $n-2$ by $n-2$
	submatrix $M''$.  Continuing in this way until we reach two
	dimensions, we obtain
      </p>

      <p>
	$$M = U_1 U_2 \ldots {\rm diag}(s_1, s_2, \ldots, s_n) \ldots V_2 V_1,$$
      </p>

      <p>
	where $U_1, V_1, U_2, V_2, \ldots$ are all orthogonal
	matrices.  Since a product of orthogonal matrices is itself an
	orthogonal matrix, we obtain
      </p>

      <p>
	$$M = U \, {\rm diag}(s_1, s_2, \ldots, s_n) \, V$$
      </p>

      <p>
	for orthogonal matrices $U$ and $V$. This is the singular
	value decomposition.
      </p>

      <p>
	It's notable that we developed the ideas underlying this proof
	in a visual environment depicting two spatial dimensions.
	We've then used algebraic-and-textual reasoning to extend that
	intuition to higher dimensions.  This is a common procedure in
	paper-and-pencil based mathematical reasoning.  Mathematicians
	develop fairly sophisticated ways of using informal
	two-dimensional representations to support more rigorous
	$n$-dimensional reasoning.  Consider, for example, the
	following <a href="http://mathoverflow.net/a/26010">remark by
	mathematician Gil Kalai</a> on high-dimensional reasoning:
      </p>

      <p>
	<img src="images/milman.jpg" width="200px;" style="float:
	right; margin-left: 10px;"/>
	<em>Vitali Milman, who works in high-dimensional convexity, likes
	to draw high-dimensional convex bodies in a non-convex way.
	This is to convey the point that if you take the convex hull
	of a few points on the unit sphere of $R^n$, then for large
	$n$ very little of the measure of the convex body is anywhere
	near the corners, so in a certain sense the body is a bit like
	a small sphere with long thin &ldquo;spikes&rdquo;.
	</em>
      </p>

      <p>
	A powerful exploratory medium for mathematics would build in
	such representational ideas, and would understand how to use
	them to support the transition from informal reasoning about
	low-dimensional representations to high-dimensional proofs.
      </p>

      
      <p><a name="appB"></a>
	<h2>Appendix B: finding the maximal stretching for a matrix</h2>
      </p>

      <p>
	Our earlier discussion showed that the largest singular value
	$s_1$ for a $2 \times 2$ matrix $M$ is equal to the maximal
	degree of stretching $\|Ms\|$. In fact, it's straightforward
	to adapt the reasoning in Appendix A to show that this is true
	also for an $n \times n$ matrix.  That is, suppose an $n
	\times n$ matrix $M$ has singular value decomposition
      </p>

      <p>
	$$M = U \,\mbox{diag}(s_1, s_2, \ldots, s_n) V,$$
      </p>

      <p>
	with singular values $s_1 \geq s_2 \geq \ldots \geq s_n \geq
	0$.  Then the maximal degree of stretching is just
      </p>

      <p>
	$$\max_{\|v \| = 1} \| Mv \| = s_1.$$
      </p>

      <p>
	While this is a nice connection, it's not obvious it helps us
	figure out the maximal degree of stretching.  After all, at
	this point we haven't figured out an explicit way of computing
	the singular values for a given matrix $M$. Fortunately, with
	a little work we can figure out not just $s_1$, but all the
	singular values.  To do this, observe that from the SVD we
	have
      </p>

      <p>
	$$M^T M = V^T \mbox{diag}(s_1^2, s_2^2, \ldots, s_n^2) V$$
      </p>

      <p>
	since $U$ is an orthogonal matrix, and thus satisfies $U^T U =
	I$.  Inspecting the last displayed equation, we see that the
	eigenvalues of $M^TM$ are just the squares of the singular
	values, $s_1^2, s_2^2, \ldots$.  And so $s_1$ is just the
	square root of the largest eigenvalue of $M^TM$.  This
	eigenvalue <em>is</em> easy to compute, which makes the
	singular value $s_1$ easy to compute.  And that, in turn,
	makes it easy to compute the maximal degree of stretching for
	$M$.
      </p>

      <p>
	Summing up, the maximal degree of stretching for a matrix $M$
	is equal to the square root of the largest eigenvalue of
	$M^TM$.  This gives an easy, computationally feasible way of
	computing the maximal degree of stretching, and thus solves
	our original problem.  This also illustrates a point made when
	we first discussed the SVD: knowing the SVD is true sometimes
	makes it much easier to reason about a matrix.
      </p>

    </div>

  </body>
</html>

